{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WHEN_UNLOCKED_THIS_DEVICE_ONLY = exports.WHEN_UNLOCKED = exports.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY = exports.ALWAYS_THIS_DEVICE_ONLY = exports.ALWAYS = exports.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY = exports.AFTER_FIRST_UNLOCK = void 0;\nexports.deleteItemAsync = deleteItemAsync;\nexports.getItemAsync = getItemAsync;\nexports.isAvailableAsync = isAvailableAsync;\nexports.setItemAsync = setItemAsync;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar _ExpoSecureStore = _interopRequireDefault(require(\"./ExpoSecureStore\"));\n\nvar AFTER_FIRST_UNLOCK = _ExpoSecureStore.default.AFTER_FIRST_UNLOCK;\nexports.AFTER_FIRST_UNLOCK = AFTER_FIRST_UNLOCK;\nvar AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY = _ExpoSecureStore.default.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\nexports.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY = AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\nvar ALWAYS = _ExpoSecureStore.default.ALWAYS;\nexports.ALWAYS = ALWAYS;\nvar WHEN_PASSCODE_SET_THIS_DEVICE_ONLY = _ExpoSecureStore.default.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\nexports.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY = WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\nvar ALWAYS_THIS_DEVICE_ONLY = _ExpoSecureStore.default.ALWAYS_THIS_DEVICE_ONLY;\nexports.ALWAYS_THIS_DEVICE_ONLY = ALWAYS_THIS_DEVICE_ONLY;\nvar WHEN_UNLOCKED = _ExpoSecureStore.default.WHEN_UNLOCKED;\nexports.WHEN_UNLOCKED = WHEN_UNLOCKED;\nvar WHEN_UNLOCKED_THIS_DEVICE_ONLY = _ExpoSecureStore.default.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\nexports.WHEN_UNLOCKED_THIS_DEVICE_ONLY = WHEN_UNLOCKED_THIS_DEVICE_ONLY;\nvar VALUE_BYTES_LIMIT = 2048;\n\nfunction isAvailableAsync() {\n  return _regenerator.default.async(function isAvailableAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", !!_ExpoSecureStore.default.getValueWithKeyAsync);\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction deleteItemAsync(key) {\n  var options,\n      _args2 = arguments;\n  return _regenerator.default.async(function deleteItemAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n          _ensureValidKey(key);\n\n          if (_ExpoSecureStore.default.deleteValueWithKeyAsync) {\n            _context2.next = 4;\n            break;\n          }\n\n          throw new _expoModulesCore.UnavailabilityError('SecureStore', 'deleteItemAsync');\n\n        case 4:\n          _context2.next = 6;\n          return _regenerator.default.awrap(_ExpoSecureStore.default.deleteValueWithKeyAsync(key, options));\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction getItemAsync(key) {\n  var options,\n      _args3 = arguments;\n  return _regenerator.default.async(function getItemAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n\n          _ensureValidKey(key);\n\n          _context3.next = 4;\n          return _regenerator.default.awrap(_ExpoSecureStore.default.getValueWithKeyAsync(key, options));\n\n        case 4:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction setItemAsync(key, value) {\n  var options,\n      _args4 = arguments;\n  return _regenerator.default.async(function setItemAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n\n          _ensureValidKey(key);\n\n          if (_isValidValue(value)) {\n            _context4.next = 4;\n            break;\n          }\n\n          throw new Error(\"Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.\");\n\n        case 4:\n          if (_ExpoSecureStore.default.setValueWithKeyAsync) {\n            _context4.next = 6;\n            break;\n          }\n\n          throw new _expoModulesCore.UnavailabilityError('SecureStore', 'setItemAsync');\n\n        case 6:\n          _context4.next = 8;\n          return _regenerator.default.awrap(_ExpoSecureStore.default.setValueWithKeyAsync(value, key, options));\n\n        case 8:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _ensureValidKey(key) {\n  if (!_isValidKey(key)) {\n    throw new Error(\"Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \\\".\\\", \\\"-\\\", and \\\"_\\\".\");\n  }\n}\n\nfunction _isValidKey(key) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction _isValidValue(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  if (_byteCount(value) > VALUE_BYTES_LIMIT) {\n    console.warn('Provided value to SecureStore is larger than 2048 bytes. An attempt to store such a value will throw an error in SDK 35.');\n  }\n\n  return true;\n}\n\nfunction _byteCount(value) {\n  var bytes = 0;\n\n  for (var i = 0; i < value.length; i++) {\n    var codePoint = value.charCodeAt(i);\n\n    if (codePoint >= 0xd800 && codePoint < 0xe000) {\n      if (codePoint < 0xdc00 && i + 1 < value.length) {\n        var next = value.charCodeAt(i + 1);\n\n        if (next >= 0xdc00 && next < 0xe000) {\n          bytes += 4;\n          i++;\n          continue;\n        }\n      }\n    }\n\n    bytes += codePoint < 0x80 ? 1 : codePoint < 0x800 ? 2 : 3;\n  }\n\n  return bytes;\n}","map":{"version":3,"sources":["../src/SecureStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoSecureStore from './ExpoSecureStore';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\nconst VALUE_BYTES_LIMIT = 2048;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - iOS: The item's service, equivalent to `kSecAttrService`\n   * - Android: Equivalent of the public/private key pair `Alias`\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * accessing data stored in SecureStore.\n   *\n   * - iOS: Equivalent to `kSecAccessControlUserPresence`\n   * - Android: Equivalent to `setUserAuthenticationRequired(true)` (requires API 23). Complete functionality\n   * is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`\n   * value used for the others non-authenticated operations.\n   */\n  requireAuthentication?: boolean;\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string;\n  /**\n   * __(iOS only)__ Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible`\n   * property. See Apple's documentation on [keychain item accessibility](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-SW18).\n   * Default value: `SecureStore.WHEN_UNLOCKED`.\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n};\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils witch `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently this resolves `true` on iOS and Android only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if the value couldn't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n\n  if (!ExpoSecureStore.deleteValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'deleteItemAsync');\n  }\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Fetch the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value, or `null` if there is no entry\n * for the given key. The promise will reject if an error occurred while retrieving the value.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  _ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Store a keyâ€“value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters\n * `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that will reject if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  _ensureValidKey(key);\n  if (!_isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n  if (!ExpoSecureStore.setValueWithKeyAsync) {\n    throw new UnavailabilityError('SecureStore', 'setItemAsync');\n  }\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\nfunction _ensureValidKey(key: string) {\n  if (!_isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction _isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction _isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (_byteCount(value) > VALUE_BYTES_LIMIT) {\n    console.warn(\n      'Provided value to SecureStore is larger than 2048 bytes. An attempt to store such a value will throw an error in SDK 35.'\n    );\n  }\n  return true;\n}\n\n// copy-pasted from https://stackoverflow.com/a/39488643\nfunction _byteCount(value: string) {\n  let bytes = 0;\n\n  for (let i = 0; i < value.length; i++) {\n    const codePoint = value.charCodeAt(i);\n\n    // Lone surrogates cannot be passed to encodeURI\n    if (codePoint >= 0xd800 && codePoint < 0xe000) {\n      if (codePoint < 0xdc00 && i + 1 < value.length) {\n        const next = value.charCodeAt(i + 1);\n\n        if (next >= 0xdc00 && next < 0xe000) {\n          bytes += 4;\n          i++;\n          continue;\n        }\n      }\n    }\n\n    bytes += codePoint < 0x80 ? 1 : codePoint < 0x800 ? 2 : 3;\n  }\n\n  return bytes;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}